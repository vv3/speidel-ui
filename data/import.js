// Generated by CoffeeScript 1.9.3
(function() {
  Brauhaus.Recipe.fromBeerXml = function(xml) {
    var doc, fermentable, fermentableNode, fermentableProperty, i, j, k, l, len, len1, len10, len11, len2, len3, len4, len5, len6, len7, len8, len9, m, mash, mashProperty, n, o, p, parser, q, r, recipe, recipeNode, recipeProperty, recipes, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, spice, spiceNode, spiceProperty, step, stepNode, stepProperty, styleNode, t, yeast, yeastNode, yeastProperty;
    recipes = [];
    parser = new DOMParser();
    doc = parser.parseFromString(xml, 'text/xml');
    ref = doc.documentElement.childNodes || [];
    for (i = 0, len = ref.length; i < len; i++) {
      recipeNode = ref[i];
      if (recipeNode.nodeName.toLowerCase() !== 'recipe') {
        continue;
      }
      recipe = new Brauhaus.Recipe();
      ref1 = recipeNode.childNodes || [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        recipeProperty = ref1[j];
        switch (recipeProperty.nodeName.toLowerCase()) {
          case 'name':
            recipe.name = recipeProperty.textContent;
            break;
          case 'brewer':
            recipe.author = recipeProperty.textContent;
            break;
          case 'batch_size':
            recipe.batchSize = parseFloat(recipeProperty.textContent);
            break;
          case 'boil_size':
            recipe.boilSize = parseFloat(recipeProperty.textContent);
            break;
          case 'boil_time':
            recipe.boilTime = parseFloat(recipeProperty.textContent);
            break;
          case 'efficiency':
            recipe.mashEfficiency = parseFloat(recipeProperty.textContent);
            break;
          case 'primary_age':
            recipe.primaryDays = parseFloat(recipeProperty.textContent);
            break;
          case 'primary_temp':
            recipe.primaryTemp = parseFloat(recipeProperty.textContent);
            break;
          case 'secondary_age':
            recipe.secondaryDays = parseFloat(recipeProperty.textContent);
            break;
          case 'secondary_temp':
            recipe.secondaryTemp = parseFloat(recipeProperty.textContent);
            break;
          case 'tertiary_age':
            recipe.tertiaryDays = parseFloat(recipeProperty.textContent);
            break;
          case 'tertiary_temp':
            recipe.tertiaryTemp = parseFloat(recipeProperty.textContent);
            break;
          case 'carbonation':
            recipe.bottlingPressure = parseFloat(recipeProperty.textContent);
            break;
          case 'carbonation_temp':
            recipe.bottlingTemp = parseFloat(recipeProperty.textContent);
            break;
          case 'age':
            recipe.agingDays = parseFloat(recipeProperty.textContent);
            break;
          case 'age_temp':
            recipe.agingTemp = parseFloat(recipeProperty.textContent);
            break;
          case 'style':
            recipe.style = {
              og: [1.000, 1.150],
              fg: [1.000, 1.150],
              ibu: [0, 150],
              color: [0, 500],
              abv: [0, 14],
              carb: [1.0, 4.0]
            };
            ref2 = recipeProperty.childNodes || [];
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              styleNode = ref2[k];
              switch (styleNode.nodeName.toLowerCase()) {
                case 'name':
                  recipe.style.name = styleNode.textContent;
                  break;
                case 'category':
                  recipe.style.category = styleNode.textContent;
                  break;
                case 'og_min':
                  recipe.style.og[0] = parseFloat(styleNode.textContent);
                  break;
                case 'og_max':
                  recipe.style.og[1] = parseFloat(styleNode.textContent);
                  break;
                case 'fg_min':
                  recipe.style.fg[0] = parseFloat(styleNode.textContent);
                  break;
                case 'fg_max':
                  recipe.style.fg[1] = parseFloat(styleNode.textContent);
                  break;
                case 'ibu_min':
                  recipe.style.ibu[0] = parseFloat(styleNode.textContent);
                  break;
                case 'ibu_max':
                  recipe.style.ibu[1] = parseFloat(styleNode.textContent);
                  break;
                case 'color_min':
                  recipe.style.color[0] = parseFloat(styleNode.textContent);
                  break;
                case 'color_max':
                  recipe.style.color[1] = parseFloat(styleNode.textContent);
                  break;
                case 'abv_min':
                  recipe.style.abv[0] = parseFloat(styleNode.textContent);
                  break;
                case 'abv_max':
                  recipe.style.abv[1] = parseFloat(styleNode.textContent);
                  break;
                case 'carb_min':
                  recipe.style.carb[0] = parseFloat(styleNode.textContent);
                  break;
                case 'carb_max':
                  recipe.style.carb[1] = parseFloat(styleNode.textContent);
              }
            }
            break;
          case 'fermentables':
            ref3 = recipeProperty.childNodes || [];
            for (l = 0, len3 = ref3.length; l < len3; l++) {
              fermentableNode = ref3[l];
              if (fermentableNode.nodeName.toLowerCase() !== 'fermentable') {
                continue;
              }
              fermentable = new Brauhaus.Fermentable();
              ref4 = fermentableNode.childNodes || [];
              for (m = 0, len4 = ref4.length; m < len4; m++) {
                fermentableProperty = ref4[m];
                switch (fermentableProperty.nodeName.toLowerCase()) {
                  case 'name':
                    fermentable.name = fermentableProperty.textContent;
                    break;
                  case 'amount':
                    fermentable.weight = parseFloat(fermentableProperty.textContent);
                    break;
                  case 'yield':
                    fermentable["yield"] = parseFloat(fermentableProperty.textContent);
                    break;
                  case 'color':
                    fermentable.color = parseFloat(fermentableProperty.textContent);
                    break;
                  case 'add_after_boil':
                    fermentable.late = fermentableProperty.textContent.toLowerCase() === 'true';
                }
              }
              recipe.fermentables.push(fermentable);
            }
            break;
          case 'hops':
          case 'miscs':
            ref5 = recipeProperty.childNodes || [];
            for (n = 0, len5 = ref5.length; n < len5; n++) {
              spiceNode = ref5[n];
              if ((ref6 = spiceNode.nodeName.toLowerCase()) !== 'hop' && ref6 !== 'misc') {
                continue;
              }
              spice = new Brauhaus.Spice();
              ref7 = spiceNode.childNodes || [];
              for (o = 0, len6 = ref7.length; o < len6; o++) {
                spiceProperty = ref7[o];
                switch (spiceProperty.nodeName.toLowerCase()) {
                  case 'name':
                    spice.name = spiceProperty.textContent;
                    break;
                  case 'amount':
                    spice.weight = parseFloat(spiceProperty.textContent);
                    break;
                  case 'alpha':
                    spice.aa = parseFloat(spiceProperty.textContent);
                    break;
                  case 'time':
                    spice.time = parseFloat(spiceProperty.textContent);
                    break;
                  case 'use':
                    spice.use = spiceProperty.textContent;
                    break;
                  case 'form':
                    spice.form = spiceProperty.textContent;
                }
              }
              recipe.spices.push(spice);
            }
            break;
          case 'yeasts':
            ref8 = recipeProperty.childNodes || [];
            for (p = 0, len7 = ref8.length; p < len7; p++) {
              yeastNode = ref8[p];
              if (yeastNode.nodeName.toLowerCase() !== 'yeast') {
                continue;
              }
              yeast = new Brauhaus.Yeast();
              ref9 = yeastNode.childNodes || [];
              for (q = 0, len8 = ref9.length; q < len8; q++) {
                yeastProperty = ref9[q];
                switch (yeastProperty.nodeName.toLowerCase()) {
                  case 'name':
                    yeast.name = yeastProperty.textContent;
                    break;
                  case 'type':
                    yeast.type = yeastProperty.textContent;
                    break;
                  case 'form':
                    yeast.form = yeastProperty.textContent;
                    break;
                  case 'attenuation':
                    yeast.attenuation = parseFloat(yeastProperty.textContent);
                }
              }
              recipe.yeast.push(yeast);
            }
            break;
          case 'mash':
            mash = recipe.mash = new Brauhaus.Mash();
            ref10 = recipeProperty.childNodes || [];
            for (r = 0, len9 = ref10.length; r < len9; r++) {
              mashProperty = ref10[r];
              switch (mashProperty.nodeName.toLowerCase()) {
                case 'name':
                  mash.name = mashProperty.textContent;
                  break;
                case 'grain_temp':
                  mash.grainTemp = parseFloat(mashProperty.textContent);
                  break;
                case 'sparge_temp':
                  mash.spargeTemp = parseFloat(mashProperty.textContent);
                  break;
                case 'ph':
                  mash.ph = parseFloat(mashProperty.textContent);
                  break;
                case 'notes':
                  mash.notes = mashProperty.textContent;
                  break;
                case 'mash_steps':
                  ref11 = mashProperty.childNodes || [];
                  for (s = 0, len10 = ref11.length; s < len10; s++) {
                    stepNode = ref11[s];
                    if (stepNode.nodeName.toLowerCase() !== 'mash_step') {
                      continue;
                    }
                    step = new Brauhaus.MashStep();
                    ref12 = stepNode.childNodes || [];
                    for (t = 0, len11 = ref12.length; t < len11; t++) {
                      stepProperty = ref12[t];
                      switch (stepProperty.nodeName.toLowerCase()) {
                        case 'name':
                          step.name = stepProperty.textContent;
                          break;
                        case 'type':
                          step.type = stepProperty.textContent;
                          break;
                        case 'infuse_amount':
                          step.waterRatio = parseFloat(stepProperty.textContent) / recipe.grainWeight();
                          break;
                        case 'step_temp':
                          step.temp = parseFloat(stepProperty.textContent);
                          break;
                        case 'end_temp':
                          step.endTemp = parseFloat(stepProperty.textContent);
                          break;
                        case 'step_time':
                          step.time = parseFloat(stepProperty.textContent);
                          break;
                        case 'decoction_amt':
                          step.waterRatio = parseFloat(stepProperty.textContent) / recipe.grainWeight();
                      }
                    }
                    mash.steps.push(step);
                  }
              }
            }
        }
      }
      recipes.push(recipe);
    }
    return recipes;
  };

}).call(this);
